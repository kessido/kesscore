# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_functional.ipynb (unless otherwise specified).

__all__ = ['zip_cycle_longest', 'lmap', 'lzip', 'lfilter', 'lrange', 'Lmap', 'Lzip', 'Lfilter', 'Lrange', 'isinstance',
           'compose_star', 'add_kwargs', 'get_all_public_attr', 'pcolkw']

# Cell
from .imports import *
from functools import wraps

# Cell
def zip_cycle_longest(*args):
    "Like `itertools.zip_longest` but `cycle`s through elements of all but longest argument"
    args = L(list(args)).map(list)
    n    = args.map(len).reduce(max)
    for i in range(n): yield tuple(a[i%len(a)] for a in args)

# Cell
def _wrapify(f, t):
    @wraps(f)
    def _inner(*args,**kwargs): return t(f(*args,**kwargs))
    return _inner
_listify = partial(_wrapify, t=list)
_Listify = partial(_wrapify, t=L)

# Cell
lmap = _listify(map)
lzip = _listify(zip)
lfilter = _listify(filter)
lrange = _listify(range)
Lmap = _Listify(map)
Lzip = _Listify(zip)
Lfilter = _Listify(filter)
Lrange = _Listify(range)

# Cell
def _all(self:L)->bool: return all(self)
L.all = _all

# Cell
@patch
def all_eq(self:L)->bool: return all([self[i] == self[i-1] for i in range(1, len(self))])

# Cell
_isinstance = isinstance
def isinstance(obj, class_or_tuple=None):
    'Like isinstance but support creating partial versions, e.g, isinstance(int)(1) is True.'
    if class_or_tuple is None:
        class_or_tuple = obj
        def _inner(obj):
            return _isinstance(obj, class_or_tuple)
        _inner.__doc__ = f'Check if `obj` is of type\\s: {class_or_tuple}'
        return _inner
    return _isinstance(obj,class_or_tuple)

# Cell
def compose_star(*funcs):
    'like compose but pass *x to functions'
    def _inner(*x):
        for f in funcs: x = f(*x)
        return x
    return _inner

# Cell
@patch
def group_by(self:L, key=noop):
    res = dict()
    for v in self: res.setdefault(key(v), L()).append(v)
    return res

# Cell
def add_kwargs(**kwargs):
    "Decorator: add argument with default value to `**kwargs` in both signature and function"
    def _f(f):
        @wraps(f)
        def _inner(*args, **kw): return f(*args, **{**kwargs, **kw})
        sig = inspect.signature(_inner)
        sigd = dict(sig.parameters)
        for k,v in kwargs.items():
            if k in sigd.keys():
                assert sigd[k].kind.name not in ['POSITIONAL_ONLY', 'VAR_KEYWORD', 'VAR_POSITIONAL'], \
                       f'cannot assign an existing variable ({k!r}) of type {sigd[k].kind.name}'
                sigd[k] = sigd[k].replace(default=v, kind=inspect._ParameterKind.KEYWORD_ONLY)
            else: sigd[k] = inspect.Parameter(k, inspect._ParameterKind.KEYWORD_ONLY, default=v)
        params = [[p for p in sigd.values() if p.kind == t] for t in range(5)]
        _inner.__signature__ = sig.replace(parameters=concat(*params))
        return _inner
    return _f

# Cell
def get_all_public_attr(o): 'Return all public field\\funcs'; return {k:getattr(o,k) for k in dir(o) if not k.startswith('_')}

# Cell
def pcolkw(f, *, use_locals=True, use_kwargs=True, use_globals=False):
    '''Partial Collected kwargs: Call function with relevant arguments collected from frame above. (global->local->kwargs_outer->kwargs)'''
    params = inspect.signature(f).parameters.values()
    for p in params:
        assert p.kind.name not in ['POSITIONAL_ONLY', 'VAR_POSITIONAL', 'VAR_KEYWORD'], f'Unsupported parameter in function: {p.name!r} is a {p.kind.name} parameter.'
    params = L(params).map(lambda p: p.name)

    fr = sys._getframe(1)

    def filter_rel(d): return {k:v for k,v in d.items() if k in params}
    globs  = filter_rel(fr.f_globals) if use_globals else {}
    locls  = filter_rel(fr.f_locals)  if use_locals else {}
    kwargs_outer = filter_rel(fr.f_locals['kwargs']) if use_kwargs and 'kwargs' in fr.f_locals.keys() else {}

    return partial(f, **{**globs, **locls, **kwargs_outer})
# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_functional.ipynb (unless otherwise specified).

__all__ = ['lmap', 'lzip', 'lfilter', 'lrange', 'Lmap', 'Lzip', 'Lfilter', 'Lrange', 'isinstance', 'compose_star']

# Cell
from .imports import *
from functools import wraps

# Cell
def _wrapify(f, t):
    @wraps(f)
    def _inner(*args,**kwargs): return t(f(*args,**kwargs))
    return _inner
_listify = partial(_wrapify, t=list)
_Listify = partial(_wrapify, t=L)

# Cell
lmap = _listify(map)
lzip = _listify(zip)
lfilter = _listify(filter)
lrange = _listify(range)
Lmap = _Listify(map)
Lzip = _Listify(zip)
Lfilter = _Listify(filter)
Lrange = _Listify(range)

# Cell
def _all(self:L)->bool: return all(self)
L.all = _all

# Cell
@patch
def all_eq(self:L)->bool: return all([self[i] == self[i-1] for i in range(1, len(self))])

# Cell
@patch
def assert_all_eq(self:L)->bool: assert self.all_eq(), f'Not all elements are equal. {self.unique()=}. ({coll_repr(self)})'

# Cell
@patch
def assert_eq(self:L, other)->bool:
    assert isinstance(other, (L, tuple, list)), f'Unsupported type to compare with {type(other)=}'
    assert len(self) == len(other), f'list lengths are not equal. {len(self)=}, {len(other)=}'
    for i in range(len(self)): assert self[i] == other[i], f'element {i=} is not equal in lists. {self[i]=}, {other[i]=}'

# Cell
_isinstance = isinstance
def isinstance(obj, class_or_tuple=None):
    'Like isinstance but support creating partial versions, e.g, isinstance(int)(1) is True.'
    if class_or_tuple is None:
        class_or_tuple = obj
        def _inner(obj):
            return _isinstance(obj, class_or_tuple)
        _inner.__doc__ = f'Check if `obj` is of type\\s: {class_or_tuple}'
        return _inner
    return _isinstance(obj,class_or_tuple)

# Cell
def compose_star(*funcs):
    'like compose but pass *x to functions'
    def _inner(*x):
        for f in funcs: x = f(*x)
        return x
    return _inner
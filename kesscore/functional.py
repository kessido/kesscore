# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_functional.ipynb (unless otherwise specified).

__all__ = ['zip_cycle_longest', 'lmap', 'lzip', 'lfilter', 'lrange', 'Lmap', 'Lzip', 'Lfilter', 'Lrange', 'isinstance',
           'compose_star']

# Cell
from .imports import *
from functools import wraps

# Cell
def zip_cycle_longest(*args):
    "Like `itertools.zip_longest` but `cycle`s through elements of all but longest argument"
    args = L(list(args)).map(list)
    n    = args.map(len).reduce(max)
    for i in range(n): yield tuple(a[i%len(a)] for a in args)

# Cell
def _wrapify(f, t):
    @wraps(f)
    def _inner(*args,**kwargs): return t(f(*args,**kwargs))
    return _inner
_listify = partial(_wrapify, t=list)
_Listify = partial(_wrapify, t=L)

# Cell
lmap = _listify(map)
lzip = _listify(zip)
lfilter = _listify(filter)
lrange = _listify(range)
Lmap = _Listify(map)
Lzip = _Listify(zip)
Lfilter = _Listify(filter)
Lrange = _Listify(range)

# Cell
def _all(self:L)->bool: return all(self)
L.all = _all

# Cell
@patch
def all_eq(self:L)->bool: return all([self[i] == self[i-1] for i in range(1, len(self))])

# Cell
_isinstance = isinstance
def isinstance(obj, class_or_tuple=None):
    'Like isinstance but support creating partial versions, e.g, isinstance(int)(1) is True.'
    if class_or_tuple is None:
        class_or_tuple = obj
        def _inner(obj):
            return _isinstance(obj, class_or_tuple)
        _inner.__doc__ = f'Check if `obj` is of type\\s: {class_or_tuple}'
        return _inner
    return _isinstance(obj,class_or_tuple)

# Cell
def compose_star(*funcs):
    'like compose but pass *x to functions'
    def _inner(*x):
        for f in funcs: x = f(*x)
        return x
    return _inner
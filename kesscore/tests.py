# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_tests.ipynb (unless otherwise specified).

__all__ = ['is_not_close', 'test_not_close', 'test_all_eq', 'test_all', 'test_eq', 'test_type']

# Cell
from .imports import *
from .functional import *
import types

# Cell
def is_not_close(a,b,eps=1e-5):
    "Is `a` not within `eps` of `b`"
    return not is_close(a,b,eps)
def test_not_close(a,b,eps=1e-5):
    "`test` that `a` is not within `eps` of `b`"
    test(a,b,partial(is_not_close,eps=eps),f'close [{eps=}]')

# Internal Cell
@patch
def assert_all_eq(self:L)->bool: assert self.all_eq(), f'Not all elements are equal. {self.unique()=}. ({coll_repr(self)})'

# Cell
def test_all_eq(*args, map=noop): L(list(args)).map(map).assert_all_eq()

# Cell
def test_all(*args, checker=noop)->bool:
    for i,v in enumerate(args): assert checker(v), f'Not all element have evaluated as True. (e.g, element {i} = {v})'

# Internal Cell
_test_eq = test_eq
def list_test_eq(a, b):
    a,b = mapped(L, [a,b])
    assert len(a) == len(b), f'List lengths are not equal. {len(a)=}, {len(b)=}'
    for i in range(len(a)): assert equals(a[i], b[i]), f'element {i=} is not equal in lists. {a[i]=}, {b[i]=}.\na = {coll_repr(a)}\nb = {coll_repr(b)}'

# Cell
def test_eq(a, b):
    if mapped(isinstance((L, range, tuple, list, types.GeneratorType, Iterator)), [a,b]).all():
        return list_test_eq(a,b)
    return _test_eq(a,b)

# Cell
def test_type(obj, class_or_tuple):
    '''assert `obj` is of type `class_or_tuple`, and o.w raise informative assert message.'''
    assert isinstance(obj, class_or_tuple), f'got instance of type {type(obj).__name__!r}, but expected {mapped(lambda x: x.__name__, class_or_tuple)!r}'